/*항상 범위 주석을 사용한다.*/
CREATE TABLE TBL_MEMBER(
   ID NUMBER CONSTRAINT PK_MEMBER PRIMARY KEY,
   MEMBER_ID VARCHAR2(255) CONSTRAINT UK_MEMBER UNIQUE,
   MEMBER_PASSWORD VARCHAR2(255),
   MEMBER_AGE NUMBER(3) CONSTRAINT CHECK_AGE CHECK(MEMBER_AGE > 0)
);

/*CREATE TABLE TBL_ORDER(
   ID NUMBER CONSTRAINT PK_ORDER PRIMARY KEY,
   MEMBER_ID NUMBER,
   ORDER_DATE DATE DEFAULT CURRENT_TIMESTAMP,
   ORDER_COUNT NUMBER DEFAULT 1,
   CONSTRAINT FK_ORDER_MEMBER FOREIGN KEY(MEMBER_ID)
   REFERENCES TBL_MEMBER(ID)
);*/

/*동물원*/
/*동물*/

CREATE TABLE TBL_ZOO(
	ID NUMBER CONSTRAINT PK_ZOO PRIMARY KEY,
	ZOO_ADDRESS VARCHAR2(255) CONSTRAINT ADDRESS_ZOO UNIQUE,
	ANIMAL_TOTAL_COUNT NUMBER CONSTRAINT CHECK_TOTAL_COUNT CHECK(ANIMAL_TOTAL_COUNT > 0),
	ZOO_KEEPER NUMBER CONSTRAINT CHECK_ZOO_KEEPER CHECK(ZOO_KEEPER > 0)
);

CREATE TABLE TBL_ANIMAL(
	ANIMAL_ID NUMBER CONSTRAINT PK_ANIMAL PRIMARY KEY,
	ZOO_ID NUMBER,
	ANIMAL_COUNT NUMBER CONSTRAINT CHECK_ANIMAL_COUNT CHECK(ANIMAL_COUNT > 0),
	CONSTRAINT FK_ANIMAL_ZOO FOREIGN KEY (ZOO_ID)
	REFERENCES TBL_ZOO(ID)
);

/*
   회원          주문              상품
   ----------------------------------------
   번호PK         번호PK         번호PK
   ----------------------------------------
   아이디U, NN   	날짜NN          이름NN
   비밀번호NN    	회원번호FK, NN   가격D=0
   이름NN      	상품번호FK, NN   재고D=0
   주소NN
   이메일
   생일
*/
/*USER
 * ----------------
 * userNumber NUMBER PK
 * ----------------
 * userId VARCHAR2(255) UNIQUE NOT NULL
 * userPw VARCHAR2(255) NOT NULL
 * userName VARCHAR2(255) NOT NULL
 * userAddress VARCHAR2(255) NOT NULL
 * userEmail VARCHAR2(255)
 * userBirthday DATE(8)
 * 
 * ORDER
 * ------------------
 * orderNumber NUMBER PK
 * ------------------
 * orderDate DATE NOT NULL
 * userId VARCHAR2(255) FK NOT NULL
 * productNumber NUMBER FK NOT NULL
 * 
 * PRODUCT
 * ---------------------
 * productNumber NUMBER PK
 * ---------------------
 * productName VARCHAR NOT NULL
 * productPrice NUMBER DEFAULT 0
 * productStock NUMBER DEFAULT 0
 * */

CREATE TABLE TBL_USER(
	USER_NUMBER NUMBER CONSTRAINT PK_USER_NUMBER PRIMARY KEY,
	USER_ID VARCHAR2(255) CONSTRAINT UK_USER_ID UNIQUE NOT NULL,
	USER_PW VARCHAR2(255) NOT NULL,
	USER_NAME VARCHAR2(255) NOT NULL,
	USER_ADDRESS VARCHAR2(255) NOT NULL,
	USER_EMAIL VARCHAR2(255),
	USER_BIRTHDAY DATE
);

CREATE TABLE TBL_PRODUCT(
	PRODUCT_NUMBER NUMBER CONSTRAINT PK_PRODUCT_NUMBER PRIMARY KEY,
	PRODUCT_PRICE NUMBER DEFAULT 0,
	PRODUCT_STOCK NUMBER DEFAULT 0
);

CREATE TABLE TBL_PREORDER(
	PREORDER_NUMBER NUMBER CONSTRAINT PK_ORDER_NUMBER PRIMARY KEY,
	PREORDER_DATE DATE DEFAULT CURRENT_TIMESTAMP,
	USER_ID VARCHAR2(255),
	PRODUCT_NUMBER NUMBER,
	CONSTRAINT FK_PREORDER_USER_ID FOREIGN KEY(USER_ID)
	REFERENCES TBL_USER (USER_ID),
	CONSTRAINT FK_PREORDER_PRODUCT_NUMBER FOREIGN KEY(PRODUCT_NUMBER)
	REFERENCES TBL_PRODUCT (PRODUCT_NUMBER)	
);

/*숙제*/
/*1. 요구사항 분석
    꽃 테이블과 화분 테이블 2개가 필요하고,
    꽃을 구매할 때 화분도 같이 구매합니다.
    꽃은 이름과 색상, 가격이 있고,
    화분은 제품번호, 색상, 모양이 있습니다.
    화분은 모든 꽃을 담을 수 없고 정해진 꽃을 담아야 합니다.

2. 개념 모델링
	꽃				화분	
	
	제품번호			제품번호
	이름				색상
	색상				모양
	가격				꽃제품번호
					
3. 논리 모델링
	꽃				화분	
	
	제품번호P			제품번호P
	이름 u nn			색상 nn
	색상	nn			모양 nn
	가격	d0			
					꽃제품번호F nn	
4. 물리 모델링
	FLOWER
flower_id number pk
------------------------
flower_name VARCHAR2(255) unique nn
flower_color VARCHAR2(255) nn
flower_price NUMBER d0

	POT
pot_id number pk
------------------------------
pot_color VARCHAR2(255) nn
pot_detail VARCHAR(255) nn
pot_flower_id fk nn
5. 구현*/

/*
 * 
 * */

CREATE TABLE TBL_FLOWER(
	FLOWER_ID NUMBER CONSTRAINT PK_FLOWER_ID PRIMARY KEY,
	FLOWER_NAME VARCHAR2(225) NOT NULL,
	FLOWER_COLOR VARCHAR2(225) NOT NULL,
	FLOWER_PRICE NUMBER DEFAULT 0
);

CREATE TABLE TBL_POT(
	POT_ID NUMBER CONSTRAINT PK_POT_ID PRIMARY KEY,
	POT_COLOR VARCHAR2(225) NOT NULL,
	POT_DETAIL VARCHAR2(225) NOT NULL,
	FLOWER_ID NUMBER,
	CONSTRAINT FK_POT_FLOWER FOREIGN KEY(FLOWER_ID)
	REFERENCES TBL_FLOWER (FLOWER_ID)
);


/*
 * 복합키(조합키)
 * */
CREATE TABLE TBL_FLOWER(
   NAME VARCHAR2(255) NOT NULL,
   COLOR VARCHAR2(255) NOT NULL,
   PRICE NUMBER DEFAULT 0,
   CONSTRAINT PK_FLOWER PRIMARY KEY(NAME, COLOR)
);

CREATE TABLE TBL_FLOWER_POT(
   ID NUMBER CONSTRAINT PK_FLOWER_POT PRIMARY KEY,
   COLOR VARCHAR2(255) NOT NULL,
   SHAPE VARCHAR2(255) NOT NULL,
   FLOWER_NAME VARCHAR2(255) NOT NULL,
   FLOWER_COLOR VARCHAR2(255) NOT NULL,
   CONSTRAINT FK_POT_FLOWER FOREIGN KEY(FLOWER_NAME, FLOWER_COLOR)
   REFERENCES TBL_FLOWER(NAME, COLOR)
);


/*
 * 슈퍼키, 서브키
 * 1:1 구조
 * */
/*슈퍼키, 서브키
 * 
 * FK를 PK로 설정한다.
 * 
 * */

/*구현된 테이블 구조 해석
 * 
 * 하나의 꽃은 하나의 화분에 담길 수 있고,
 * 하나의 화분에는 하나의 꽃만 담을 수 있는
 * 전형적인 1:1 구조이다.
 * 
 * */
CREATE TABLE TBL_FLOWER(
   ID NUMBER CONSTRAINT PK_FLOWER PRIMARY KEY,
   NAME VARCHAR2(255) NOT NULL CONSTRAINT UK_FLOWER UNIQUE,
   COLOR VARCHAR2(255) NOT NULL,
   PRICE NUMBER DEFAULT 0
);

CREATE TABLE TBL_FLOWER_POT(
   ID NUMBER CONSTRAINT PK_FLOWER_POT PRIMARY KEY,
   COLOR VARCHAR2(255) NOT NULL,
   SHAPE VARCHAR2(255) NOT NULL,
   CONSTRAINT FK_POT_FLOWER FOREIGN KEY(ID)
   REFERENCES TBL_FLOWER(ID)
);




/*
1. 요구사항 분석
    안녕하세요, 동물병원을 곧 개원합니다.
    동물은 보호자랑 항상 같이 옵니다. 가끔 보호소에서 오는 동물도 있습니다.
    보호자가 여러 마리의 동물을 데리고 올 수 있습니다.
    보호자는 이름, 나이, 전화번호, 주소가 필요하고
    동물은 병명, 이름, 나이, 몸무게가 필요합니다.

2. 개념 모델링
	보호자			동물
	보호자주민번호		식별칩
	뒷자리7자리		보호자번호
	보호자이름			동물이름
	나이				나이
	전화번호			몸무게
	주소				병명
3. 논리 모델링
	보호자				동물
	보호자주민번호			식별칩 PK
	뒷자리7자리 PK			보호자번호 FK
	보호자이름	NN			동물이름 NN
	나이	NN				나이 NN
	전화번호 U NN			몸무게 NN
	주소	NN				병명 NN
4. 물리 모델링
	MASTER
MASTER_ID NUMBER(7) PK
-------------------------------
MASTER_NAME VARCHAR2 NN
MASTER_AGE NUMBER NN
MASTER_PHONENUM NUMBER NN
MASTER_ADDRESS VARCHAR2 NN

	PET
PET_CHIP_ID NUMBER PK
MASTER_ID NUMBER FK
PET_NAME VARCHAR2 NN
PET_AGE NUMBER NN
PET_WEIGHT NUMBER NN
PET_disease_name VARCHAR2 NN
5. 구현
*/


CREATE TABLE TBL_MASTER(
    MASTER_ID NUMBER(7) CONSTRAINT PK_MASTER_ID PRIMARY KEY,
    MASTER_NAME VARCHAR2(225) NOT NULL,
    MASTER_AGE NUMBER(3) NOT NULL,
    MASTER_PHONE_NUM NUMBER(11) NOT NULL,
    MASTER_ADDRESS VARCHAR2(225) NOT NULL
);


CREATE TABLE TBL_PET(
    PET_CHIP_ID NUMBER CONSTRAINT PK_PET_CHIP_ID PRIMARY KEY,
    MASTER_ID NUMBER(7),
    PET_NAME VARCHAR2(225) NOT NULL,
    PET_AGE NUMBER(3) NOT NULL,
    PET_WEIGHT NUMBER(3, 2) NOT NULL,
    PET_DISEASE_NAME VARCHAR2(225),
    CONSTRAINT FK_PET_MASTER FOREIGN KEY (MASTER_ID)
    REFERENCES TBL_MASTER (MASTER_ID)
);

/*
1. 요구 사항
    커뮤니티 게시판을 만들고 싶어요.
    게시판에는 게시글 제목과 게시글 내용, 작성한 시간, 작성자가 있고,
    게시글에는 댓글이 있어서 댓글 내용들이 나와야 해요.
    작성자는 회원(tbl_user)정보를 그대로 사용해요.
    댓글에도 작성자가 필요해요.

2. 개념 모델링
	작성자			게시글		댓글
				
	아이디			작성자아이디	댓글작성자 아이디
	비밀번호			게시글 내용	댓글내용
	이름				작성한 시간	댓글번호
	주소				댓글번호
	이메일			게시글 제목
	생일


3. 논리 모델링

	작성자			게시글				댓글
				
	아이디PK			작성자아이디PKFK		댓글작성자 아이디 FK
	비밀번호NN		게시글 내용 NN			댓글내용 NN
	이름NN			작성한 시간 NN			댓글번호 PK
	주소NN			댓글번호 FK
	이메일NN U		게시글 제목 NN
	생일NN


4. 물리 모델링
	USER
-------------------------
USER_ID VARCHAR2 PK
USER_PS VARCHAR2 NN
USER_NAME VARCHAR2 NN
USER_ADDRESS VARCHAR2 NN
USER_MAIL VARCHAR2 NN U
USER_BIRTH DATE NN


	POST
----------------------------
USER_ID VARCHAR2 PK FK
POST_TITLE VARCHAR2 NN
POST_CONTENT VARCHAR2 NN
POST_TIME DATE NN
COMMENT_NUMBER NUMBER FK


	COMMENT
-------------------------------
COMMENT_NUMBER PK
COMMENT_CONTENT VARCHAR2 NN
USER_ID VARCHAR2 FK
5. 구현
*/




CREATE TABLE TBL_POST(
	POST_ID VARCHAR2(255) CONSTRAINT PK_POST_USER PRIMARY KEY,
	POST_TITLE VARCHAR2(50) NOT NULL,
	POST_CONTENT VARCHAR2(3000) NOT NULL,
	POST_TIME DATE DEFAULT CURRENT_TIMESTAMP,
	USER_ID VARCHAR2(255),
	COMMENT_NUMBER NUMBER,
	CONSTRAINT FK_POST_USER FOREIGN KEY(USER_ID)
	REFERENCES TBL_USER(USER_ID),
	CONSTRAINT FK_POST_COMMENT FOREIGN KEY(COMMENT_NUMBER)
	REFERENCES TBL_COMMENT(COMMENT_NUMBER)
);




CREATE TABLE TBL_COMMENT(
	COMMENT_NUMBER NUMBER CONSTRAINT PK_COMMENT_NUM PRIMARY KEY,
	COMMENT_CONTENT VARCHAR2(255) NOT NULL,
	USER_ID VARCHAR2(255),
	CONSTRAINT FK_COMMENT_USER FOREIGN KEY(USER_ID)
	REFERENCES TBL_USER(USER_ID)
);

*/

 요구 사항
    마이페이지에서 회원 프로필을 구현하고 싶습니다.
    회원당 프로필을 여러 개 설정할 수 있고,
    대표 이미지로 선택된 프로필만 화면에 보여주고 싶습니다.

2. 개념 모델링

	회원페이지		프로필			대표프로필
				
	아이디		프로필번호			회원아이디
	비밀번호		회원아이디			프로필번호
	이름					
	주소			
	이메일	
	생일


3. 논리 모델링

	회원페이지		프로필			대표프로필
				
	아이디 PK		프로필번호	PK		회원아이디 PK FK
	비밀번호 NN	회원아이디	FK		프로필번호 FK
	이름	NN				
	주소	NN		
	이메일 NN	
	생일 NN


4. 물리 모델링
	USER는 위에 재사용

	PROFIL
----------------------------
PROIFIL_NUMBER NUMBER PK
USER_ID VARCHAR2 FK NN

Representative_profile
-----------------------------
USER_ID PK FK
PROFIL_NUMBER FK

5. 구현
*/

CREATE TABLE TBL_USER(
	USER_ID VARCHAR2(255) CONSTRAINT PK_USER_ID PRIMARY KEY,
	USER_PS VARCHAR2(255) NOT NULL,
	USER_NAME VARCHAR2(10) NOT NULL,
	USER_ADDRESS VARCHAR2(255) NOT NULL,
	USER_MAIL VARCHAR2(255) CONSTRAINT UK_USER_MAIL UNIQUE NOT NULL,
	USER_BIRTH DATE NOT NULL
);


CREATE TABLE TBL_PROFIL(
	PROFIL_ID NUMBER CONSTRAINT PK_PROFIL PRIMARY KEY,
	USER_ID VARCHAR2(255) NOT NULL,
	CONSTRAINT FK_PROFIL_USER FOREIGN KEY(USER_ID)
	REFERENCES TBL_USER(USER_ID)
);

CREATE TABLE TBL_RE_PROFIL(
	USER_ID VARCHAR2(255) CONSTRAINT PK_RE_PROFIL PRIMARY KEY,
	PROFIL_ID NUMBER NOT NULL,
	CONSTRAINT FK_RE_PROFIL_USER FOREIGN KEY(USER_ID)
	REFERENCES TBL_USER(USER_ID),
	CONSTRAINT FK_RE_PROFIL_PROFIL FOREIGN KEY(PROFIL_ID)
	REFERENCES TBL_PROFIL(PROFIL_ID)
);


/*CREATE TABLE TBL_MEMBER(
   ID NUMBER CONSTRAINT PK_MEMBER PRIMARY KEY,
   MEMBER_ID VARCHAR2(255) CONSTRAINT UK_MEMBER UNIQUE NOT NULL,
   MEMBER_PASSWORD VARCHAR2(255) NOT NULL,
   MEMBER_NAME VARCHAR2(255) NOT NULL,
   MEMBER_ADDRESS VARCHAR2(255) NOT NULL,
   MEMBER_EMAIL VARCHAR2(255),
   MEMBER_BIRTH DATE
);

CREATE TABLE TBL_PROFILE(
   ID NUMBER CONSTRAINT PK_PROFILE PRIMARY KEY,
   PROFILE_PATH VARCHAR2(255) NOT NULL,
   PROFILE_SIZE NUMBER DEFAULT 0,
   STATUS NUMBER DEFAULT 0,
   MEMBER_ID NUMBER NOT NULL,
   CONSTRAINT FK_PROFILE_MEMBER FOREIGN KEY(MEMBER_ID)
   REFERENCES TBL_MEMBER(ID)
);*/

CREATE TABLE TBL_MEMBER(
   ID NUMBER CONSTRAINT PK_MEMBER PRIMARY KEY,
   MEMBER_ID VARCHAR2(255) CONSTRAINT UK_MEMBER UNIQUE NOT NULL,
   MEMBER_PASSWORD VARCHAR2(255) NOT NULL,
   MEMBER_NAME VARCHAR2(255) NOT NULL,
   MEMBER_ADDRESS VARCHAR2(255) NOT NULL,
   MEMBER_EMAIL VARCHAR2(255),
   MEMBER_BIRTH DATE
);

CREATE TABLE GOOD_BTN(
	BTN_ID NUMBER CONSTRAINT PK_BTN PRIMARY KEY,
	BTN_STATUS NUMBER DEFAULT 0,
	RECEIVER_BTN NUMBER NOT NULL,
	SENDER_BTN NUMBER NOT NULL,
	CONSTRAINT FK_BTN_MEMBER_RECEIVERR FOREIGN KEY(RECEIVER_BTN)
	REFERENCES TBL_MEMBER(ID),
	CONSTRAINT FK_SEND_BTN_MEMBER FOREIGN KEY(SENDER_BTN)
	REFERENCES TBL_MEMBER(ID)
);

ALTER TABLE GOOD_BTN RENAME COLUMN PUSH_MEMBER_ID TO RECEIVER_BTN;
ALTER TABLE GOOD_BTN RENAME COLUMN SEND_MEMBER_ID TO SENDER_BTN;

ALTER TABLE GOOD_BTN DROP CONSTRAINT FK_PUSH_BTN_MEMBER;
ALTER TABLE GOOD_BTN DROP CONSTRAINT FK_SEND_BTN_MEMBER;

ALTER TABLE GOOD_BTN ADD
CONSTRAINT FK_BTN_MEMBER_RECEIVER FOREIGN KEY(RECEIVER_BTN)
REFERENCES TBL_MEMBER(ID);

ALTER TABLE GOOD_BTN ADD
CONSTRAINT FK_BTN_MEMBER_SENDER FOREIGN KEY(SENDER_BTN)
REFERENCES TBL_MEMBER(ID);

/*
    1. 요구사항 분석
        안녕하세요 중고차 딜러입니다.
        이번에 자동차와 차주를 관리하고자 방문했습니다.
        자동차는 여러 명의 차주로 히스토리에 남아야 하고,
        차주는 여러 대의 자동차를 소유할 수 있습니다.
        그래서 우리는 항상 등록증(Registration)을 작성합니다.
        자동차는 브랜드, 모델명, 가격, 출시날짜가 필요하고
        차주는 이름, 전화번호, 주소가 필요합니다.

    2. 개념 모델링

	차주			자동차			등록증
	차주ID		차등록번호			차주
	이름			브랜드			차등록번호
	번호			모델명
	주소			가격
				출시날짜
				차주
    				등록증

3. 논리 모델링

	차주			자동차			등록증
	차주ID PK		차등록번호	PK		차주 FK
	이름	NN		브랜드 NN			차등록번호 FK
	번호	NN		모델명 NN			등록증번호
	주소	NN		가격 
				출시날짜 NN
				차주 NN FK
    				등록증 NN FK

 4. 물리 모델링
	OWNER
------------------------
OWNER_ID NUMBER PK
OWNER_NAME VARCHAR2(255) NN
OWNER_PHONE NUMBER(11) NN
OWNER_ADDRESS VARCHAR2(255) NN

	CAR
-------------------------
CAR_ID NUMBER PK
CAR_BRAND NN
CAR_MODEL NN
CAR_PRICE NUMBER
CAR_RELEASE_DAY DATE NN
REGISTRATION_ID NUMBER FK

	REGISTRATION
---------------------------------
REGISTRATION_ID NUMBER PK
OWNER_ID NUMBER FK
CAR_ID NUMBER FK


 5. 구현
*/

CREATE TABLE TBL_OWNER(
	OWNER_ID NUMBER CONSTRAINT PK_OWNER PRIMARY KEY,
	OUNER_NAME VARCHAR2(255) NOT NULL,
	OUNER_PHONE NUMBER(11) NOT NULL,
	OUNBER_ADDRESS VARCHAR2(255) NOT NULL
);

CREATE TABLE TBL_CAR(
	CAR_ID NUMBER CONSTRAINT PK_CAR PRIMARY KEY,
	CAR_BRAND VARCHAR2(255) NOT NULL,
	CAR_MODEL VARCHAR2(255) NOT NULL,
	CAR_PRICE NUMBER NOT NULL,
	CAR_RELEASE_DAY DATE,
	
);

CREATE TABLE TBL_REGISTRATION(
	REGISTRATION_ID NUMBER CONSTRAINT PK_REGISTRATION PRIMARY KEY,
	OWNER_ID NUMBER NOT NULL,
	CAR_ID NUMBER NOT NULL,
	CONSTRAINT FK_RREGISTRATION_OWNER FOREIGN KEY(OWNER_ID)
	REFERENCES TBL_OWNER(OWNER_ID),
	CONSTRAINT FK_RREGISTRATION_CAR FOREIGN KEY(CAR_ID)
	REFERENCES TBL_CAR
);


/*
    요구사항

    학사 관리 시스템에 학생과 교수, 과목을 관리합니다.
    학생은 학번, 이름, 전공, 학년이 필요하고
    교수는 교수 번호, 이름, 전공, 직위가 필요합니다.
    과목은 고유한 과목 번호와 과목명, 학점이 필요합니다.
    학생은 여러 과목을 수강할 수 있으며,
    교수는 여러 과목을 강의할 수 있습니다.
    학생이 수강한 과목은 성적(점수)이 모두 기록됩니다.


2. 개념모델링

학생			교수			과목			성적
학번 			교수번호 		과목번호		
이름 			이름			과목명		학번
전공 			전공			학점			
학년 			직위			수강생학번		과목번호
						강의교사번호	성적점수


3. 논리모델링

학생			교수			과목				성적

학번 PK		교수번호 PK	과목번호 PK		성적ID PK
이름 NN		이름	NN		과목명 NN			학번 FK
전공 NN		전공	NN		학점	NN			
학년 NN		직위	NN		수강생학번	FK		과목번호 FK
						강의교사번호 FK		성적점수 NN


4. 물리 모델링

	STUDENT
---------------------------------
STUDENT_ID NUMBER(12) PK
STUDENT_NAME VARCHAR2(255) NN
STUDENT_MAJOR VARCHAR2(255) NN
STUDENT_CLASS NUMBER(1) NN

	PROFESSOR
----------------------------------
PROFESSOR_ID NUMBER(12) PK
PROFESSOR_NAME VARCHAR2(255) NN
PROFESSOR_MAJOR VARCHAR2(255) NN
PROFESSOR_CLASS VARCHAR2(255) NN


	SUBJECT
------------------------------------
SUBJECT_ID NUMBER(3) PK
SUBJECT_NAME VARCHAR2(255) NN
SUBJECT_CREDIT NUMBER(1) NN
STUDENT_ID NUMBER FK
PROFESSOR_ID NUMBER FK

	SCORE
-------------------------------------
SCORE_KIND NUMBER PK
STUDENT_ID NUMBER FK NN
SUBJECT_ID NUMBER FK NN
SCORE_NUMBER NUMBER NN
*/

CREATE TABLE TBL_STUDENT(
	STUDENT_ID NUMBER(12) CONSTRAINT PK_STUDENT PRIMARY KEY,
	STUDENT_NAME VARCHAR2(255) NOT NULL,
	STUDENT_MAJOR VARCHAR2(255) NOT NULL,
	STUDENT_CLASS NUMBER(1) DEFAULT 1
);

CREATE TABLE TBL_PROFESSOR(
	PROFESSOR_ID NUMBER(12) CONSTRAINT PK_PORFESSOR PRIMARY KEY,
	PROFESSOR_NAME VARCHAR2(255) NOT NULL,
	PROFESSOR_MAJOR VARCHAR2(255) NOT NULL,
	PROFESSOR_CLASS VARCHAR2(255) NOT NULL
);

CREATE TABLE TBL_SUBJECT(
	SUBJECT_ID NUMBER(3) CONSTRAINT PK_SUBJECT PRIMARY KEY,
	SUBJECT_NAME VARCHAR2(255) NOT NULL CONSTRAINT UK_SUBJECT UNIQUE,
	SUBJECT_CREDIT NUMBER(1) NOT NULL,
	STATUS NUMBER DEFAULT 0
);


CREATE TABLE TBL_SCORE(
	SCORE_KIND NUMBER CONSTRAINT PK_SCORE PRIMARY KEY,
	STUDENT_ID NUMBER(12) NOT NULL,
	SUBJECT_ID NUMBER(3) NOT NULL,
	SCORE_NUMBER NUMBER(3,2) DEFAULT 0.0,
	CONSTRAINT FK_SCORE_STUDENT FOREIGN KEY(STUDENT_ID)
	REFERENCES TBL_STUDENT(STUDENT_ID),
	CONSTRAINT FK_SCORE_SUBJECTT FOREIGN KEY(SUBJECT_ID)
	REFERENCES TBL_SUBJECT(SUBJECT_ID)
);

CREATE TABLE TBL_LECTURE(
	LECTURE_ID NUMBER CONSTRAINT PK_LECTURE PRIMARY KEY,
	SUBJECT_ID NUMBER(12),
	PROFESSOR_ID NUMBER(12),
	CONSTRAINT FK_LECTURE_SUBJECT FOREIGN KEY(SUBJECT_ID)
	REFERENCES TBL_SUBJECT(SUBJECT_ID),
	CONSTRAINT FK_LECTURE_PROFESSOR FOREIGN KEY(PROFESSOR_ID)
	REFERENCES TBL_PROFESSOR(PROFESSOR_ID)
);

/*
1. 요구사항
    대카테고리, 소카테고리가 필요해요.
    
    
2. 개념 모델링
	대카테고리			소카테고리
	대카 번호			소카 번호
	대카 이름			소카 이름
					대카 번호		


3. 논리 모델링

	대카테고리			소카테고리
	대카 번호PK		소카 번호 PK
	대카 이름			소카 이름
					대카 번호 FK
	

4. 물리 모델링
	BIG_CATEGORY
------------------------------
BIG_CATEGORY_ID NUMBER PK
BIG_CATEGORY_NAME VARCHAR2(255)

SMALL_CATEGORY
------------------------------
SMALL_CATEGORY_ID NUMBER PK
SMALLCATEGORY_NAME
BIG_CATEGORY_ID NUMBER FK


5. 구현
*/

       


 /*요구 사항
 * 
 * 회의실 예약 서비스를 제작하고 싶습니다.
 * 회원별로 등급이 존재하고 사무실마다 회의실이 여러 개 있습니다.
 * 회의실 이용 가능 시간은 파트 타임으로서 여러 시간대가 존재합니다.
 * */



/*2. 개념 모델링
	
	회원			사무실		회의실		등급			파트타임
	번호			사무실번호		회의실번호		등급번호		시간순서(ID)
	이름			사무실위치		사무실번호		등급이름		회의실번호
	등급

3. 논리 모델링
	회원			사무실		회의실		등급			파트타임
	
	번호 PK		사무실번호 PK	회의실번호	PK	등급번호 PK	시간순서(ID) PK
	이름 NN		사무실위치 NN	사무실번호	FK	등급이름 NN	회의실번호	FK
	등급 FK

4. 물리 모델링
	USER
------------------------
USER_ID NUMBER PK
USER_NAME VARCHAR2(255) NN
TIER_ID NUMBER FK NN

	OFFICE
-------------------------
OFFICE_ID NUMBER PK
OFFICE_ADDRESS VARCHAR2(255)

	MEETING_ROOM
----------------------------------
MEETING_ROOM_ID NUMBER PK
OFFICE_ID NUMBER FK NN
PART_TIME_ID NUMBER FK

	TIER
-----------------------------
TIER_ID NUMBER PK
TIER_NAME VARCHAR2(10) NN


	PART_TIME
--------------------------------
PART_TIME_ID NUMBER PK
PART_TIME_DATE DATE
 */


CREATE TABLE TBL_USER(
	USER_ID NUMBER CONSTRAINT PK_USER PRIMARY KEY,
	USER_NAME VARCHAR2(255) NOT NULL,
	TIER_ID NUMBER,
	CONSTRAINT FK_USER_TIER FOREIGN KEY(TIER_ID)
	REFERENCES TBL_TIER(TIER_ID)
);

CREATE TABLE TBL_OFFICE(
	OFFICE_ID NUMBER CONSTRAINT PK_OFFICE PRIMARY KEY,
	OFFICE_ADDRESS VARCHAR2(255) NOT NULL
);

CREATE TABLE MEETING_ROOM(
	METING_ROOM_ID NUMBER CONSTRAINT PK_MEETING_ROOM PRIMARY KEY,
	OFFICE_ID NUMBER,
	PART_TIME_ID NUMBER,
	USER_ID NUMBER,
	CONSTRAINT FK_MEETING_ROOM_OFFICE FOREIGN KEY(OFFICE_ID)
	REFERENCES TBL_OFFICE(OFFICE_ID),
	CONSTRAINT FK_MEETING_ROOM_PART_TIME FOREIGN KEY(PART_TIME_ID)
	REFERENCES PART_TIME(PART_TIME_ID),
	CONSTRAINT FK_MEETING_ROOM_USER FOREIGN KEY(USER_ID)
	REFERENCES TBL_USER(USER_ID)
);

ALTER TABLE MEETING_ROOM RENAME COLUMN EETING_ROOM_ID TO METING_ROOM_ID;

CREATE TABLE TBL_TIER(
	TIER_ID NUMBER CONSTRAINT PK_TIER PRIMARY KEY,
	TIER_NAME VARCHAR2(10) NOT NULL
);


CREATE TABLE PART_TIME(
	PART_TIME_ID NUMBER CONSTRAINT PK_PART_TIME PRIMARY KEY,
	PART_TIME_DATE DATE NOT NULL
);

CREATE TABLE TBL_RESERVATION

/*
 * 느낀점
 * 회의실을 예약하는 것으로 기획했으나 파트타임을 알아야 예약관리가 가능함
 * 그래서 파트타임 테이블까진 생성했으나, 예약시스템테이블은 만들지 않았었음
 * 예약시스템테이블까지 만들어놔야 FK로 조회하여 파트타임과 예약가능한 회의실을 찾아서 예약이 구현가능해짐
 * 
 * CREATE TABLE TBL_MEMBER(
   ID NUMBER CONSTRAINT PK_MEMBER PRIMARY KEY,
   MEMBER_ID VARCHAR2(255) CONSTRAINT UK_MEMBER UNIQUE NOT NULL,
   MEMBER_PASSWORD VARCHAR2(255) NOT NULL,
   MEMBER_NAME VARCHAR2(255) NOT NULL,
   MEMBER_ADDRESS VARCHAR2(255) NOT NULL,
   MEMBER_EMAIL VARCHAR2(255),
   MEMBER_BIRTH DATE
);

CREATE TABLE TBL_OFFICE(
   ID NUMBER CONSTRAINT PK_OFFICE PRIMARY KEY,
   OFFICE_NAME VARCHAR2(255) NOT NULL,
   OFFICE_LOCATION VARCHAR2(255) NOT NULL
);

CREATE TABLE TBL_CONFERENCE_ROOM(
   ID NUMBER CONSTRAINT PK_CONFERENCE_ROOM PRIMARY KEY,
   OFFICE_ID NUMBER NOT NULL,
   CONSTRAINT FK_CONFERENCE_ROOM_OFFICE FOREIGN KEY(OFFICE_ID)
   REFERENCES TBL_OFFICE(ID)
);

CREATE TABLE TBL_PART_TIME(
   ID NUMBER CONSTRAINT PK_PART_TIME PRIMARY KEY,
   START_TIME DATE NOT NULL,
   END_TIME DATE NOT NULL
   CONFERENCE_ROOM_ID NUMBER,
   CONSTRAINT FK_PART_TIME_CONFERENCE_ROOM FOREIGN KEY(CONFERENCE_ROOM_ID)
   REFERENCES TBL_CONFERENCE_ROOM(ID)
);

CREATE TABLE TBL_RESERVATION(
   ID NUMBER CONSTRAINT PK_RESERVATION PRIMARY KEY,
   MEMBER_ID NUMBER NOT NULL,
   PART_TIME_ID NUMBER NOT NULL,
   CONSTRAINT FK_RESERVATION_MEMBER FOREIGN KEY(MEMBER_ID)
   REFERENCES TBL_MEMBER_ID(ID),
   CONSTRAINT FK_RESERVATION_PART_TIME FOREIGN KEY(PART_TIME_ID)
   REFERENCES TBL_PART_TIME(ID)
);

 * 
 * */


/* 1. 요구사항
 * 숙소를 예약 하려고함
 * 계곡마다 숙소가 여러개 있음.
 * 숙소 하나당 한명의 회원밖에 예약 못함
 * 
 * 2. 개념 모델링
 * 숙소			계곡			회원
 * 숙소번호		계곡번호		회원번호
 * 숙소이름		계곡이름		회원이름
 * 수용인원		계곡위치		회원주소
 * 회원번호					
 * 계곡번호
 * 
 * 
 *  * 3. 논리 모델링
 * 숙소			계곡			회원
 * 숙소번호PK		계곡번호PK	회원번호PK
 * 숙소이름NN		계곡이름NN	회원이름NN
 * 수용인원NN		계곡위치NN	회원주소NN
 * 회원번호FK					
 * 계곡번호FK
 * 
 * 4. 물리 모델링
 * 		USER
 * ----------------------
 * USER_ID NUMBER PK
 * USER_NAME VARCHAR2 NN
 * USER_ADDRESS VARCHAR2 NN
 * USER_PHONE NUMBER NN
 * 
 * 		VALLEY
 * ------------------------
 * VALLEY_ID NUMBER PK
 * VALLEY_NAME VARCHAR2 NN
 * VALLEY_ADDRESS VARCHAR2 NN
 * 
 * 
 * 		LODGING
 * LODGING_ID NUMBER PK
 * LODGING_NAME VARCHAR2 NN
 * LODGING_CAPACITY NUMBER NN
 * USER_ID NUMBER FK NN
 * VALLEY_ID NUMBER FK NN
 * 
 */


CREATE TABLE TBL_MEMBER(
 	MEMBER_ID NUMBER CONSTRAINT PK_MEMBER PRIMARY KEY,
 	MEMBER_NAME VARCHAR2(255) NOT NULL,
 	MEMBER_ADDRESS VARCHAR2(255) NOT NULL,
	MEMBER_PHONE NUMBER(11) NOT NULL
);

CREATE TABLE TBL_VALLEY(
	VALLEY_ID NUMBER CONSTRAINT PK_VALLEY PRIMARY KEY,
	VALLEY_NAME VARCHAR2(255),
	VALLEY_ADDRESS VARCHAR2(255) NOT NULL
);

CREATE TABLE TBL_LODGING(
	LODGING_ID NUMBER CONSTRAINT PK_LODGING PRIMARY KEY,
	LODGING_NAME VARCHAR2(255),
	LODGING_CAPACITY NUMBER NOT NULL,
	MEMBER_ID NUMBER,
	VALLEY_ID NUMBER,
	CONSTRAINT FK_LODGING_MEMBER FOREIGN KEY(MEMBER_ID)
	REFERENCES TBL_MEMBER(MEMBER_ID),
	CONSTRAINT FK_LODGING_VALLEY FOREIGN KEY(VALLEY_ID)
	REFERENCES TBL_VALLEY(VALLEY_ID)
);


/*1. 요구사항
 * 집을 계약합니다.
 * 집하나에는 한명의 계약자밖에 없으며.
 * 집을 계약하는 사람은 여러채를 계약할 수 있으며, 전 집주인이 누구인지
 * 알 수 있어야합니다.
 * 집은 주소 방 개수, 평수, 주소가 있고,
 * 계약자는 이름, 휴대폰번호, 가족인원 수가 표시되어야 합니다.
 *
 *2. 개념 모델링
 *
 *	계약자			집				계약서
 *계약자번호			집번호			계약번호
 *이름				주소				계약자번호
 *폰번호				방 개수			집번호
 *가족인원수			
 *
 *
 *3. 논리 모델링
 *
 *	계약자			집				계약서
 *계약자번호PK			집번호 PK			계약번호 PK
 *이름 NN			주소	NN			계약자번호 FK
 *폰번호	NN			방 개수 D=0		집번호 FK
 *가족인원수 D=1		
 *
 * 4. 물리 모델링
 *	CONTRACTOR
 *---------------------
 *CONTRACTOR_ID NUMBER PK
 *CONTRACTOR_NAME VARCHAR2(255) NN
 *CONTRACTOR_PHONE NUMBER(11) NN
 *CONTRACTOR_FAMILY NUMBER D=0
 *
 *	HOUSE
 *---------------------
 *HOUSE_ID NUMBER PK
 *HOUSE_ADDRESS VARCHAR2(255)
 *HOUSE_ROOM NUMBER D=1
 *
 *CONTRACT
 *----------------
 *CONTRACT_ID NUMBER PK
 *CONTRACTOR_ID NUMBER FK
 *HOUSE_ID NUMBER FK
 *
 *
 * */

CREATE TABLE TBL_CONTRACTOR(
	CONTRACTOR_ID NUMBER CONSTRAINT PK_CONTRACTOR PRIMARY KEY,
	CONTRACTOR_NAME VARCHAR2(255) NOT NULL,
 	CONTRACTOR_PHONE NUMBER(11) NOT NULL,
 	CONTRACTOR_FAMILY NUMBER(2) DEFAULT 1
);

CREATE TABLE TBL_HOUSE(
	HOUSE_ID NUMBER CONSTRAINT PK_HOUSE PRIMARY KEY,
 	HOUSE_ADDRESS VARCHAR2(255) NOT NULL,
 	HOUSE_ROOM NUMBER DEFAULT 1
);

CREATE TABLE TBL_CONTRACT(
	CONTRACT_ID NUMBER CONSTRAINT PK_CONTRACT PRIMARY KEY,
	CONTRACTOR_ID NUMBER,
	HOUSE_ID NUMBER,
	CONSTRAINT FK_CONTRACT_CONTRACTOR FOREIGN KEY(CONTRACTOR_ID)
	REFERENCES TBL_CONTRACTOR(CONTRACTOR_ID),
	CONSTRAINT FK_CONTRACT_HOUSE FOREIGN KEY(HOUSE_ID)
	REFERENCES TBL_HOUSE(HOUSE_ID)
);


/*
 * 1. 요구 사항
회원은 시스템에 등록되어야 합니다.
회원마다 고유한 회원 번호가 부여됩니다.
회원의 이름, 이메일, 전화번호를 관리합니다.
회원은 등급(일반, 프리미엄, VIP)으로 구분됩니다.
각 회원의 등록 날짜를 기록합니다.
 * 
 * 
 * 2. 개념 모델링
 * 	회원				시스템			등급
 *	회원번호 			등록번호			등급번호
 * 	이름				회원번호			등급이름
 * 	이메일			등급번호			
 * 	전화번호			등록날짜						
 *
 * 	3. 논리모델링
 *  * 2. 개념 모델링
 * 	회원				시스템			등급
 *	회원번호PK 		등록번호PK		등급번호PK
 * 	이름	NN			회원번호 FK		등급이름 NN
 * 	이메일 NN			등급번호 FK			
 * 	전화번호 NN		등록날짜 
 * 
 * 4. 물리 모델링
 * 
 * 		USER
 * ----------------------------
 * USER_ID NUMBER PK
 * USER_NAME VARCHAR2(255) NN
 * USER_EMAIL VARCHAR2(255) NN
 * USER_PHONE NUMBER(11) NN
 * 
 * 		SYSTEM
 * ----------------------------
 * SYSTEM_ID NUMBER PK
 * USER_ID NUMBER FK
 * TIER_ID NUMBER FK
 * SYSTEM_DATE DTAE DEFAULT TIMESTAMP
 * 
 * 		TIER
 * ----------------------------
 * TIER_ID NUMBER PK
 * TIER_NAME VARCHAR2(255)
 * 
 * 
 * 5. 구현
 * 
 * */
CREATE TABLE TBL_USER(
	USER_ID NUMBER CONSTRAINT PK_USER PRIMARY KEY,
 	USER_NAME VARCHAR2(255) NOT NULL,
 	USER_EMAIL VARCHAR2(255) NOT NULL,
 	USER_PHONE NUMBER(11) NOT NULL
);

CREATE TABLE TBL_SYSTEM(
 	SYSTEM_ID NUMBER CONSTRAINT PK_SYSTEM PRIMARY KEY,
 	USER_ID NUMBER,
 	TIER_ID NUMBER,
 	SYSTEM_DATE DATE DEFAULT CURRENT_TIMESTAMP,
 	CONSTRAINT FK_SYSTEM_USER FOREIGN KEY(USER_ID)
 	REFERENCES TBL_USER(USER_ID),
 	CONSTRAINT FK_SYSTEM_TIER FOREIGN KEY(TIER_ID)
 	REFERENCES TBL_TIER(TIER_ID)
);

CREATE TABLE TBL_TIER(
	TIER_ID NUMBER CONSTRAINT PK_TIER PRIMARY KEY,
	TIER_NAME VARCHAR2(255) NOT NULL
);


/*
 * 1. 요구사항
 * 위의 회원관리 시스템에 맞춰 도서대출 시스템구축
 * 한사람은 여러권의 책을 빌릴 수 있음
 * 회원의 등급에 따라 대출기간이 다름
 * 책마다 카테고리가 있음
 * 
 * 
 * */


/*
1. 요구사항
   유치원을 하려고 하는데, 아이들이 체험학습 프로그램을 신청해야 합니다.
   아이들 정보는 이름, 나이, 성별이 필요하고 학부모는 이름, 나이, 주소, 전화번호, 성별이 필요해요
   체험학습은 체험학습 제목, 체험학습 내용, 이벤트 이미지 여러 장이 필요합니다.
   아이들은 여러 번 체험학습에 등록할 수 있어요.
    
2. 개념 모델링
	아이			학부모		체험학습			등록프로그램
	ID			ID			ID				등록ID
	이름			이름			제목				등록날짜
	나이			나이			내용				체험학습ID
	성별			주소			이벤트			학부모ID
				전화번호		이미지			아이ID
				성별
				
3. 논리 모델링
	아이			학부모		체험학습			등록프로그램
	ID PK		ID PK		ID PK			등록ID PK
	이름	NN		이름	NN		제목	NN			등록날짜 NN
	나이	NN		나이	NN		내용	NN			체험학습ID FK
	성별	NN		주소	NN		이벤트 			학부모ID FK
				전화번호 NN	이미지 			아이ID FK
				성별 NN


4. 물리 모델링
	KIDS
--------------------------------
KIDS_ID NUMBER PK
KIDS_NAME VARCHAR2(255) NN
KIDS_AGE NUMBER(2) NN
KIDS_GENDER VARCHAR2(1) NN

	PARENTS
---------------------------	
PARENTS_ID NUMBER PK
PARENTS_NAME VARCHAR2(255) NN
PARENTS_AGE NUMBER(3) NN
PARENTS_ADDRESS VARCHAR2(255) NN
PARENTS_PHONE NUMBER(11) NN
PARENTS_GENDER VARCHAR2(1)

	FIELD_STUDY
-------------------------------
FIELD_STUDY_ID NUMBER PK
FIELD_STUDY_TITLE VARCHAR2(255) NN
FIELD_STUDY_DETAIL VARCHAR2(255) NN
FIELD_STUDY_EVENT VARCHAR2(255)
FIELD_STUDY_IMAGE VARCHAR2(255)

	SYSTEM
---------------------------------
SYSTEM_ID NUMBER PK
SYSTEM_DATE DATE DEFAULT CURRENT_TIMESTAMP
FIELD_STUDY_ID NUMBER FK
PARENTS_ID NUMBER FK
KIDS_ID NUMBER FK
5. 구현
*/

CREATE TABLE TBL_KIDS(
	KIDS_ID NUMBER CONSTRAINT PK_KIDS PRIMARY KEY,
	KIDS_NAME VARCHAR2(255) NOT NULL,
	KIDS_AGE NUMBER(2) NOT NULL,
	KIDS_GENDER VARCHAR2(1) NOT NULL
);

CREATE TABLE TBL_PARENTS(
	PARENTS_ID NUMBER CONSTRAINT PK_PARENTS PRIMARY KEY,
	PARENTS_NAME VARCHAR2(255) NOT NULL,
	PARENTS_AGE NUMBER(3) NOT NULL,
	PARENTS_ADDRESS VARCHAR2(255) NOT NULL,
	PARENTS_PHONE NUMBER(11) NOT NULL,
	PARENTS_GENDER VARCHAR2(1) NOT NULL
);

CREATE TABLE FIELD_STUDY(
FIELD_STUDY_ID NUMBER CONSTRAINT PK_FIELD_STUDY PRIMARY KEY,
FIELD_STUDY_TITLE VARCHAR2(255) NOT NULL,
FIELD_STUDY_DETAIL VARCHAR2(255) NOT NULL,
FIELD_STUDY_EVENT VARCHAR2(255),
FIELD_STUDY_IMAGE VARCHAR2(255)
);

CREATE TABLE SYSTEM(
	SYSTEM_ID NUMBER CONSTRAINT PK_SYSTEM PRIMARY KEY,
	SYSTEM_DATE DATE DEFAULT CURRENT_TIMESTAMP,
	FIELD_STUDY_ID NUMBER,
	PARENTS_ID NUMBER,
	KIDS_ID NUMBER,
	CONSTRAINT FK_SYSTEM_FIELD_STUDY FOREIGN KEY(FIELD_STUDY_ID)
	REFERENCES FIELD_STUDY(FIELD_STUDY_ID),
	CONSTRAINT FK_SYSTEM_PARENTS FOREIGN KEY(PARENTS_ID)
	REFERENCES TBL_PARENTS(PARENTS_ID),
	CONSTRAINT FK_SYSTEM_KIDS FOREIGN KEY(KIDS_ID)
	REFERENCES TBL_KIDS(KIDS_ID)
);

/*
 * 아이정보가 담긴 테이블
 * 학부모의 정보가 담긴 테이블
 * 체험학습의 정보가 담긴 테이블
 * 체험학습 신청프로그램을 담을 테이블에
 * 체험학습의 정보를 확인할 수 있는 FK
 * 신청하는학부모의 정보를 확인할 수 있는 FK
 * 체험학습을 가는 아이의 정보를 확인할 수 있는 FK
 * 를 담고, 신청시 신청한 시간이 언제인지 확인할 수 있는 CURRENT_TIMESTAMP컬럼도 추가
 * */

CREATE TABLE TBL_KINDERGARTEN(
   ID NUMBER CONSTRAINT PK_KINDERGARTEN PRIMARY KEY,
   KINDERGARTEN_NAME VARCHAR2(255),
   KINDERGARTEN_ADDRESS VARCHAR2(255)
);

CREATE TABLE TBL_PARENT(
   ID NUMBER CONSTRAINT PK_PARENT PRIMARY KEY,
   PARENT_NAME VARCHAR2(255) NOT NULL,
   PARENT_ADDRESS VARCHAR2(255) NOT NULL,
   PARENT_PHONE VARCHAR2(255) NOT NULL,
   PARENT_GENDER NUMBER DEFAULT 3
);

CREATE TABLE TBL_CHILD(
   ID NUMBER CONSTRAINT PK_CHILD PRIMARY KEY,
   CHILD_AGE NUMBER NOT NULL,
   CHILD_GENDER NUMBER DEFAULT 3,
   PARENT_ID NUMBER,
   CONSTRAINT FK_CHILD_PARENT FOREIGN KEY(PARENT_ID)
   REFERENCES TBL_PARENT(ID)
);

CREATE TABLE TBL_FIELD_TRIP(
   ID NUMBER CONSTRAINT PK_FIELD_TRIP PRIMARY KEY,
   FIELD_TRIP_TITLE VARCHAR2(255),
   FIELD_TRIP_CONTENT VARCHAR2(255),
   KINDERGARTEN_ID NUMBER,
   CONSTRAINT FK_FIELD_TRIP_KINDERGARTEN FOREIGN KEY(KINDERGARTEN_ID)
   REFERENCES TBL_KINDERGARTEN(ID)
);

CREATE TABLE TBL_FILE(
   ID NUMBER CONSTRAINT PK_FILE PRIMARY KEY,
   FILE_NAME VARCHAR2(255),
   FILE_PATH VARCHAR2(255),
   FILE_SIZE NUMBER
);

CREATE TABLE TBL_FIELD_TRIP_FILE(
   ID NUMBER CONSTRAINT PK_FIELD_DRIP_FILE PRIMARY KEY,
   FIELD_TRIP_ID NUMBER NOT NULL,
   CONSTRAINT FK_FIELD_TRIP_FILE_FIELD_TRIP FOREIGN KEY(FIELD_TRIP_ID)
   REFERENCES TBL_FIELD_TRIP(ID),
   CONSTRAINT FK_FIELD_TRIP_FILE_FILE FOREIGN KEY(ID)
   REFERENCES TBL_FILE(ID)
);

CREATE TABLE TBL_MEMBER(
   ID NUMBER CONSTRAINT PK_MEMBER PRIMARY KEY,
   MEMBER_ID VARCHAR2(255) CONSTRAINT UK_MEMBER UNIQUE NOT NULL,
   MEMBER_PASSWORD VARCHAR2(255) NOT NULL,
   MEMBER_NAME VARCHAR2(255) NOT NULL,
   MEMBER_ADDRESS VARCHAR2(255) NOT NULL,
   MEMBER_EMAIL VARCHAR2(255),
   MEMBER_BIRTH DATE,
   KINDERGARTEN_ID NUMBER,
   CONSTRAINT FK_MEMBER_KINDERGARTEN FOREIGN KEY(KINDERGARTEN_ID)
   REFERENCES TBL_KINDERGARTEN(ID)
);


/*
1. 요구사항
   안녕하세요, 광고 회사를 운영하려고 준비중인 사업가입니다.
   광고주는 기업이고 기업 정보는 이름, 주소, 대표번호, 기업종류(스타트업, 중소기업, 중견기업, 대기업)입니다.
   광고는 제목, 내용이 있고 기업은 여러 광고를 신청할 수 있습니다.
   기업이 광고를 선택할 때에는 카테고리로 선택하며, 대카테고리, 중카테고리, 소카테고리가 있습니다.

2. 개념 모델링
	기업			광고		광고선택테이블		대카		중카		소카		신청프로그램	신청파일
	id			ID			ID			ID		ID		ID		선택ID		파일ID
	이름			제목			광고ID		내용		내용		내용		신청시 파일ID	신청기업정보ID
	주소			내용			광고주ID				대카참조	중카참조	
	대표번호		소카참조
	종류

3. 논리 모델링
	기업			광고		광고선택테이블		대카		중카		소카		신청프로그램		신청파일
	id PK			ID PK			ID PK			ID PK		ID PK		ID PK		선택ID PK FK		파일ID PK
	이름			제목			광고ID		내용		내용		내용		신청시 파일ID FK		신청기업정보ID FK
	주소			내용			광고주ID				대카참조FK	중카참조FK	
	대표번호		소카참조 FK
	종류

4. 물리 모델링

	COMPANY
---------------------------
COMPANY_ID NUMBER PK
COMPANY_NAME VARCHAR2(255) NN
COMPANY_ADDRESS VARCHAR(255) NN
COMPANY_CEO VARCHAR(255) NN
COMPANY_CEO_PHONE VARCHAR(255) NN
COMPANY_TYPE NUMBER

	ADVERTISEMENT
------------------------------------------
ADVERTISEMENT_ID NUMBER PK
ADVERTISEMENT_TITLE VARCHAR2(255) NN
ADVERTISEMENT_DETAIL VARCHAR2(255) NN
LITTLE_CATEGORY_ID NUMBER FK NN

	SELECT_ADVERTISEMENT
---------------------------------------------
SELECT_ADVERTISEMENT_ID NUMBER PK
ADVERTISEMENT_ID NUMBER FK
COMPANY_ID NUMBER FK

	BIG_CATEGORY
--------------------------------------------
BIG_CATEGORY_ID NUMBER PK
BIG_CATEGORY_TITLE VARCHAR2(255) NN

	MIDDLE_CATEGORY
--------------------------------------------
MIDDLE_CATEGORY_ID NUMBER PK
MIDDLE_CATEGORY_TITLE VARCHAR2(255) NN
BIG_CATEGORY_ID NUMBER FK

	LITTLE_CATEGORY
--------------------------------------------
LITTLE_CATEGORY_ID NUMBER PK
LITTLE_CATEGORY_TITLE VARCHAR2(255) NN
MIDDLE_CATEGORY_ID NUMBER FK

	APPLICATION_PROGREM
-------------------------------------------
SELECT_ADVERTISEMENT_ID NUMBER PK FK
FILE_ID FK 

	FILE
---------------------------------------------
FILE_ID NUMBER PK
COMPANY_ID NUMBER FK
*/

CREATE TABLE TBL_COMPANY(
   ID NUMBER CONSTRAINT PK_COMPANY PRIMARY KEY,
   COMAPNY_NAME VARCHAR2(255) NOT NULL,
   COMAPNY_ADDRESS VARCHAR2(255) NOT NULL,
   COMAPNY_TEL VARCHAR2(255) NOT NULL,
   COMAPNY_TYPE NUMBER
);

CREATE TABLE TBL_CATEGORY_A(
   ID NUMBER CONSTRAINT PK_CATEGORY_A PRIMARY KEY,
   CATEGORY_A_NAME VARCHAR2(255)
);

CREATE TABLE TBL_CATEGORY_B(
   ID NUMBER CONSTRAINT PK_CATEGORY_B PRIMARY KEY,
   CATEGORY_B_NAME VARCHAR2(255),
   CATEGORY_A_ID NUMBER,
   CONSTRAINT FK_CATEGORY_B_CATEGORY_A FOREIGN KEY(CATEGORY_A_ID)
   REFERENCES TBL_CATEGORY_A(ID)
);

CREATE TABLE TBL_CATEGORY_C(
   ID NUMBER CONSTRAINT PK_CATEGORY_C PRIMARY KEY,
   CATEGORY_C_NAME VARCHAR2(255),
   CATEGORY_B_ID NUMBER,
   CONSTRAINT FK_CATEGORY_C_CATEGORY_B FOREIGN KEY(CATEGORY_B_ID)
   REFERENCES TBL_CATEGORY_B(ID)
);

CREATE TABLE TBL_ADVERTISEMENT(
   ID NUMBER CONSTRAINT PK_ADVERTISEMENT PRIMARY KEY,
   ADVERTISEMENT_TITLE VARCHAR2(255) NOT NULL,
   ADVERTISEMENT_CONTENT VARCHAR2(255) NOT NULL,
   COMPANY_ID NUMBER,
   CONSTRAINT FK_ADVERTISEMENT_COMPANY FOREIGN KEY(COMPANY_ID)
   REFERENCES TBL_COMPANY(ID)
);

ALTER TABLE TBL_ADVERTISEMENT ADD (CATEGORY_C_ID NUMBER);
ALTER TABLE TBL_ADVERTISEMENT ADD 
CONSTRAINT FK_ADVERTISEMENT_CATEGORY_C FOREIGN KEY(CATEGORY_C_ID)
REFERENCES TBL_CATEGORY_C(ID);

CREATE TABLE TBL_APPLY(
   ID NUMBER CONSTRAINT PK_APPLY PRIMARY KEY,
   COMPANY_ID NUMBER NOT NULL, 
   ADVERTISEMENT_ID NUMBER NOT NULL,
   CONSTRAINT FK_APPLY_COMPANY FOREIGN KEY(COMPANY_ID)
   REFERENCES TBL_COMPANY(ID),
   CONSTRAINT FK_APPLY_ADVERTISEMENT FOREIGN KEY(ADVERTISEMENT_ID)
   REFERENCES TBL_ADVERTISEMENT(ID)
);


/*
1. 요구사항
   음료수 판매 업체입니다. 음료수마다 당첨번호가 있습니다. 
   음료수의 당첨번호는 1개이고 당첨자의 정보를 알아야 상품을 배송할 수 있습니다.
   당첨 번호마다 당첨 상품이 있고, 당첨 상품이 배송 중인지 배송 완료인지 구분해야 합니다.

2. 개념 모델링
	당첨자	음료수		상품			업체		당첨신청
	ID		ID			ID			ID		신청번호ID
	번호		당첨번호		배송상태		업체명	음료수ID
	주소		판매업체ID		상품이름		주소		당첨자ID
	이름					신청ID		연락처	업체ID
						업체ID

3. 논리 모델링
	당첨자		음료수		상품			업체			당첨신청
	
	ID NUM PK		ID NUM PK		ID NUM PK		ID NUM PK		신청번호ID NUM PK
	번호	NN		당첨번호 D=0	배송상태 D=0	업체명 NN		음료수ID FK NN
	주소	NN		판매업체ID	NN	상품이름 NN	주소 NN		당첨자ID FK NN
	이름	NN					신청ID FK NN	연락처 NN		
							업체ID FK NN

4. 물리 모델링
	WINNER
--------------------------
WINNER_ID NUMBER PK
WINNER_NAME VARCHAR2(255) NN
WINNER_PHONE NUMBER(11) NN
WINNER_ADDRESS VARCHAR2 NN

	DRINK
----------------------------------
DRINK_ID NUMBER PK
DRINK_STATUS NUMBER DFAULT 0
STORE_ID NUMBER FK

	STORE
----------------------------------
STORE_ID NUMBER PK
STORE_NAME VARCHAR2(255) NN
STORE_ADDRESS VARCHAR2(255) NN
STORE_PHONE NUMBER NN

	GOODS
----------------------------------
GOODS_ID NUMBER PK
GOODS_STATUS NUMBER DEFAULT 0
GOODS_NAME VARCHAR2(255) NN
APPLY_ID NUMBER FK NN
STORE_ID NUMBER FK NN

	APPLY
--------------------------------
APPLY_ID NUMBER PK
DRINK_ID FK NN
WINNER_ID FK NN

5. 구현
*/

CREATE TABLE TBL_WINNER(
	WINNER_ID NUMBER CONSTRAINT PK_WINNER PRIMARY KEY,
	WINNER_NAME VARCHAR2(255) NOT NULL,
	WINNER_PHONE NUMBER(11) NOT NULL,
	WINNER_ADDRESS VARCHAR2(255) NOT NULL
);

CREATE TABLE TBL_STORE(
	STORE_ID NUMBER CONSTRAINT PK_STORE PRIMARY KEY,
	STORE_NAME VARCHAR2(255) NOT NULL,
	STORE_ADDRESS VARCHAR2(255) NOT NULL,
	STORE_PHONE NUMBER NOT NULL
);

CREATE TABLE TBL_DRINK(
	DRINK_ID NUMBER CONSTRAINT PK_DRINK PRIMARY KEY,
	DRINK_STATUS NUMBER DEFAULT 0,
	STORE_ID NUMBER,
	CONSTRAINT FK_DRINK_STORE FOREIGN KEY(STORE_ID)
	REFERENCES TBL_STORE(STORE_ID)
);

ALTER TABLE TBL_DRINK DROP COLUMN DRINK_STATUS;
ALTER TABLE TBL_DRINK ADD WINNING_ID NUMBER;
ALTER TABLE TBL_DRINK ADD CONSTRAINT
FK_DRINK_WINNING_NUMBER FOREIGN KEY(WINNING_ID)
REFERENCES WINNING_NUMBER(WINNING_ID);

CREATE TABLE TBL_APPLY(
	APPLY_ID NUMBER CONSTRAINT PK_APPLY PRIMARY KEY,
	DRINK_ID NUMBER,
	WINNER_ID NUMBER,
	CONSTRAINT FK_APPLY_DRINK FOREIGN KEY(DRINK_ID)
	REFERENCES TBL_DRINK(DRINK_ID),
	CONSTRAINT FK_APPLY_WINNER FOREIGN KEY(WINNER_ID)
	REFERENCES TBL_WINNER(WINNER_ID)
);

CREATE TABLE GOODS(
	GOODS_ID NUMBER CONSTRAINT PK_GOODS PRIMARY KEY,
	GOODS_STATUS NUMBER DEFAULT 0,
	GOODS_NAME VARCHAR2(255) NOT NULL,
	APPLY_ID NUMBER,
	STORE_ID NUMBER,
	CONSTRAINT FK_GOODS_APPLY FOREIGN KEY(APPLY_ID)
	REFERENCES TBL_APPLY(APPLY_ID),
	CONSTRAINT FK_GOODS_STORE FOREIGN KEY(STORE_ID)
	REFERENCES TBL_STORE(STORE_ID)
);

CREATE TABLE WINNING_NUMBER(
	WINNING_ID NUMBER CONSTRAINT PK_WINNING_NUMBER PRIMARY KEY,
	WINNING_NUMBER NUMBER(6) NOT NULL
);

/*--------------------------------------------------*/
CREATE TABLE TBL_MEMBER(
   ID NUMBER CONSTRAINT PK_MEMBER PRIMARY KEY,
   MEMBER_ID VARCHAR2(255) CONSTRAINT UK_MEMBER UNIQUE NOT NULL,
   MEMBER_PASSWORD VARCHAR2(255) NOT NULL,
   MEMBER_NAME VARCHAR2(255) NOT NULL,
   MEMBER_ADDRESS VARCHAR2(255) NOT NULL,
   MEMBER_EMAIL VARCHAR2(255),
   MEMBER_BIRTH DATE
);

CREATE TABLE TBL_SOFT_DRINK(
   ID NUMBER CONSTRAINT PK_SOFT_DRINK PRIMARY KEY,
   SOFT_DRINK_NAME VARCHAR2(255)
);

CREATE TABLE TBL_PRODUCT(
   ID NUMBER CONSTRAINT PK_PRODUCT PRIMARY KEY,
   PRODUCT_NAME VARCHAR2(255) NOT NULL,
   PRODUCT_PRICE NUMBER DEFAULT 0,
   PRODUCT_STOCK NUMBER DEFAULT 0
);

CREATE TABLE TBL_LOTTERY(
   ID NUMBER CONSTRAINT PK_LOTTERY PRIMARY KEY,
   LOTTERY_NUMBER VARCHAR2(255) NOT NULL,
   PRODUCT_ID NUMBER,
   CONSTRAINT FK_LOTTERY_PRODUCT FOREIGN KEY(PRODUCT_ID)
   REFERENCES TBL_PRODUCT(ID)
);

CREATE TABLE TBL_CIRCULATION(
   ID NUMBER CONSTRAINT PK_CIRCULATION PRIMARY KEY,
   SOFT_DRINK_ID NUMBER,
   LOTTERY_ID NUMBER,
   CONSTRAINT FK_CIRCULATION_SOFT_DRINK FOREIGN KEY(SOFT_DRINK_ID)
   REFERENCES TBL_SOFT_DRINK(ID),
   CONSTRAINT FK_CIRCULATION_LOTTERY FOREIGN KEY(LOTTERY_ID)
   REFERENCES TBL_LOTTERY(ID)
);

CREATE TABLE TBL_DILIVERY(
   ID NUMBER CONSTRAINT PK_DILIVERY PRIMARY KEY,
   MEMBER_ID NUMBER NOT NULL,
   PRODUCT_ID NUMBER NOT NULL,
   STATUS NUMBER DEFAULT 0,
   CONSTRAINT FK_DILIVERY_MEMBER FOREIGN KEY(MEMBER_ID)
   REFERENCES TBL_MEMBER(ID),
   CONSTRAINT FK_DILIVERY_PRODUCT FOREIGN KEY(PRODUCT_ID)
   REFERENCES TBL_PRODUCT(ID)
);
/*-----------------------------------------------*/

/*
1. 요구사항
   이커머스 창업 준비중입니다. 기업과 사용자 간 거래를 위해 기업의 정보와 사용자 정보가 필요합니다.
   기업의 정보는 기업 이름, 주소, 대표번호가 있고
   사용자 정보는 이름, 주소, 전화번호가 있습니다. 결제 시 사용자 정보와 기업의 정보, 결제한 카드의 정보 모두 필요하며,
   상품의 정보도 필요합니다. 상품의 정보는 이름, 가격, 재고입니다.
   사용자는 등록한 카드의 정보를 저장할 수 있으며, 카드의 정보는 카드번호, 카드사, 회원 정보가 필요합니다.

2. 개념 모델링
	기업			사용자정보			상품정보			카드			결제
	ID			ID				ID				ID			주문번호
	이름			이름				이름				카드번호		사용자ID
	주소			주소				가격				카드사		기업ID
	대표번호		전화번호			재고				회원정보		상품ID

3. 논리 모델링
	기업			사용자정보			상품정보		카드			결제
	ID PK			ID PK				ID PK			ID PK			주문번호 PK
	이름	NN		이름NN			이름	NN		카드번호		사용자ID FK
	주소	NN		주소NN			가격D0		카드사		기업ID FK
	대표번호NN	전화번호NN		재고D0		사용자ID FK	상품ID FK



4. 물리 모델링
	COMPANY
-----------------------
ID NUMBER PK
COMPANY_NAME NN
CONANY_ADDRESS NN
COMPANY_PHONE NN

	USER
---------------------------
ID NUMBER PK
USER_NAME NN
USER_ADDRESS NN
USER_PHONE NN

	PRODUCT
---------------------------
ID
PRODUCT_NAME NN
PRODUCT_PRICE
PRODUCT_STOCK

	CARD
--------------------------
ID NUMBER PK
CARD_NUMBER NN
CARD_TYPE NN
USER_ID FK

	
	PAYMENT
---------------------------------
ID PK
USER_ID FK
COMPANY_ID FK
PRODUCT_ID FK

5. 구현
*/

CREATE TABLE TBL_COMPANY(
ID NUMBER CONSTRAINT PK_COMPANY PRIMARY KEY,
COMPANY_NAME VARCHAR2(255) NOT NULL,
CONANY_ADDRESS VARCHAR2(255) NOT NULL,
COMPANY_PHONE NUMBER NOT NULL
);

CREATE TABLE TBL_USER(
ID NUMBER CONSTRAINT PK_USER PRIMARY KEY,
USER_NAME VARCHAR2(255) NOT NULL,
USER_ADDRESS VARCHAR2(255) NOT NULL,
USER_PHONE NUMBER NOT NULL
);

CREATE TABLE TBL_PRODUCT(
ID NUMBER CONSTRAINT PK_PRODUCT PRIMARY KEY,
PRODUCT_NAME VARCHAR2(255) NOT NULL,
PRODUCT_PRICE NUMBER DEFAULT 0,
PRODUCT_STOCK NUMBER DEFAULT 0
);

CREATE TABLE TBL_CARD(
ID NUMBER CONSTRAINT PK_CARD PRIMARY KEY,
CARD_NUMBER NUMBER(19) NOT NULL,
CARD_TYPE VARCHAR2(255) NOT NULL,
USER_ID NUMBER,
CONSTRAINT FK_CARD_USER FOREIGN KEY(USER_ID)
REFERENCES TBL_USER(ID)
);

CREATE TABLE TBL_PAYMENT(
ID NUMBER CONSTRAINT PK_PAYMENT PRIMARY KEY,
USER_ID NUMBER,
COMPANY_ID NUMBER,
PRODUCT_ID NUMBER,
CONSTRAINT FK_PAYMENT_USER FOREIGN KEY(USER_ID)
REFERENCES TBL_USER(ID),
CONSTRAINT FK_PAYMENT_COMPANY FOREIGN KEY(COMPANY_ID)
REFERENCES TBL_COMPANY(ID),
CONSTRAINT FK_PAYMENT_PRODUCT FOREIGN KEY(PRODUCT_ID)
REFERENCES TBL_PRODUCT(ID)
);

CREATE TABLE TBL_PAY(
ID NUMBER CONSTRAINT PK_PAY PRIMARY KEY,
CARD_ID NUMBER,
PAYMENT_ID NUMBER,
CONSTRAINT FK_PAY_CARD FOREIGN KEY(CARD_ID)
REFERENCES TBL_CARD(ID),
CONSTRAINT FK_PAY_PAYMENT FOREIGN KEY(PAYMENT_ID)
REFERENCES TBL_PAYMENT(ID)
);